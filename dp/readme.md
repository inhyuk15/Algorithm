
dp를 생각했다면 문제가 부분문제로 쪼개지는가를 살펴야한다.

종만북에서는
dp의 풀이를 완전탐색으로부터 정의한다.

중복되는 부분문제 풀이를 메모이제이션해서 시간복잡도를 줄이자는 것이다.
이렇게 보면 dp는 공간복잡도로 결정된다 즉

얼만큼의 공간을 탐색할 것인가가 시간복잡도를 결정한다.


문제를 풀면서 생각이 조금 달라졌다.
일반적으로 이 부분문제를 정의하기도 힘들다.

완전탐색으로 정의하기도 힘들고 완전탐색에서 재귀적으로 정의하는 것도 쉽지 않다.


따라서 나는 어떤 문제를 해결하기 위해 이 문제가 다른 부분문제들의 조합으로 풀릴 수 있는가를 확인하기로 했다.

11049번을 예시로 들자.


0번부터 n-1번의 행렬이 있다.
이 행렬들을 조합해서 최소 곱셈 가중치를 구해야한다.

int func(int left, int right)를 만들었는가
왜 인수가 두개인가

습관으로?

알고리즘 문제들을 살펴보면 이렇게 인수를 두개를 받는 함수를 정말 많이 만들게 된다.
근데 func(left, mid, right) 이렇게 세개를 받을 수도 있는 것이고
특히 이번 행렬곱은 세개의 행렬로 정의되니까 인자를 세개를 받아야하지 않나 생각할 수 도 있다.

이 문제는 깊게 생각할 수록 끝이 없는 문제이다.


결론부터 말하면 인수를 두개를 받는게 맞다.
습관이라고 한다면 올바른 습관이겠다. 왜냐하면 두 수로 표현되는 범위로 결정되는 문제이기 때문이다.

문제에서 물어보는 것도 두 수의 범위로 쿼리를 날린다고 볼 수 있다.

그러면 두 수의 인수로 문제를 해결한다고 했을 때
어떻게 접근할 것인가

left, right를 인수로 받고 이게 [left, right]범위의 행렬들의 곱셈 가중치를 반환해야한다고 한다.

그럼 이제 재귀적으로 부분문제를 쪼개려고 할 것이다.

알고리즘을 꾸준히 풀어왔다면
특정 변수 mid를 만들어서 left, right 사이에 있는 걸 (left, mid) (mid+1, right) 이런식으로 쪼개려고 하는 생각이 자연스럽게 든다.


그렇다고 바로 코드에 손이 갈수가 없다. 분명 멈추게 된다.

그렇기때문에 문제를 확실하게 정의하고 코드로 가야한다.

mid는 왜 나온 변수인가, 습관이라는 답은 해결해주지 못한다.


한가지 생각에서 시작해야한다.
현재 left, right의 해답은

"left부터 특정 mid로의 해답을 구했고
mid부터 right까지의 해답을 구한 상태라면
구할 수 있다"

"부분문제가 정의된다면 현재 문제의 답을 정의할 수 있다." 라는 생각이 든다면 수도코드를 정의할 수 있게 된다.

그럼 그 부분문제는 결국 어디서 종착을 맺는가
그것이 base 케이스이다.

이 경우는 left == right 일때 0을 반환하는 base케이스가 있다.


즉 dp는
특정 해결방법으로 부분문제를 정의했을 때 답을 구할 수 있다고 가정하고
현재 문제를 부분문제로 정의한다.

그리고 마지막으로 base 케이스를 완성하면 된다.